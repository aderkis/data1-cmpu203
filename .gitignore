interface BST {
    String toString();
    int cardinality();
    boolean isBranch();
    boolean isEmptyHuh();
    boolean member(int elt);
    BST add(int elt);
}

class Branch implements BST {
    BST left;
    int key;
    BST right;
    
    Branch (BST left, int key, BST right) {
        this.left = left;
        this.key = key;
        this.right = right;
    }
    
    public String toString() {
        String theKey = ("(" + this.key + this.left.toString() + this.right.toString() + ")");
        return theKey;
    }
    
    public boolean isBranch() {
        return true;
    }
    
    public int cardinality() {
        return 1 + this.left.cardinality() + this.right.cardinality();
    }
    
    public boolean isEmptyHuh() {
        return false;
    }
    
    public boolean member(int elt) {
        if (elt == this.key) {
            return true;
        } else if (elt < this.key) {
            return this.left.member(elt);
        } else {
            return this.right.member(elt);
    }
    
    public BST add(int elt) {
        if (elt == this.key) {
            return this;
        } else if (elt < this.key) {
            return new Branch(this.left.add(elt), this.key, this.right);
        } else {
            return new Branch(this.left, this.key, this.right.add(elt));
        }
    }
    
    public BST remove(int elt) {
        if (elt < this.key) {
            return new Branch(this.left.remove(elt),this.key, this.right);
        } else if (elt > this.key) {
            return new Branch(this.left, this.key, this.right.remove(elt));
        } else {
            return this.left.union(this.right);
        }
    }
    
    public BST union(BST u) {
        return u.union(this.left).union(this.right).add(this.key);
    }
    
    public BST inter(BST u) {
        if(u.member(this.key)) {
            return new Branch(this.left.inter(u), this.key, this.right.inter(u));
        } else {
            return this.left.union(this.right).inter(u);
        }
    }
    
    public BST diff(BST u) {
        return this.left.union(this.right).diff(u.remove(this.key));
    }
    
    public boolean equal(BST u) {
        return this.subset(u) && u.subset(this);
    }
    
    public boolean subset(BST u) {
        return u.member(this.key) && this.left.subset(u) && this.right.subset(u);
    }
}

class Empty implements BST {
    
    Empty() {}
    
    public String toString() {
        String theKey = ("empty");
        return theKey;
    }
    
    public int cardinality() {
        return 0;
    }
    
    public boolean isBranch() {
        return false;
    }
    
    public boolean isEmptyHuh() {
        return true;
    }
    
    public boolean member(int elt) {
        return false;
    }
    
    public BST add(int elt) {
        BST bot = new Empty();
        BST addElt = new Branch(bot, elt, bot);
        return addElt;
    }
    
    public BST remove(int elt) {
        return new Empty();
    }
    
    public BST union(BST u) {
        return u;
    }
    
    public BST inter(BST u) {
        return this;
    }
    
    public BST diff(BST u) {
        return u;
    }
    
    public boolean equal(BST u) {
        return u.isEmptyHuh();
    }
    
    public boolean subset(BST u) {
        return true;
    }
}

class Tests {

    //cardinality (union u t) = cardinality (t) + cardinality (u) - cardinality (inter u t)
    public static boolean unionTest(BST t, BST u) {
	return t.union(u).cardinality() == t.cardinality() + u.cardinality() - t.inter(u).cardinality();
    }
   
    //member (add t x) y = true <-> x = y \/ member t y = true
    public static boolean addMemberTest(BST t, int x, int y) {
	return t.add(x).member(y) == (x == y || t.member(y));
    } 

    //member (union s s') x = true <-> member s x = true \/ member s' x = true
    public static boolean unionMemberTest(BST t, BST u, int x) {
	return t.union(u).member(x) == (t.member(x) || u.member(x));
    }
    
    //member (inter s s') x = true <-> member s x = true /\ member s' x = true
    public static boolean interMemberTest(BST t, BST u, int x) {
	return t.inter(u).member(x) == (t.member(x) && u.member(x));
    }

    public static void main( String[] args ) {
        
        // BST example
        BST bot = new Empty();
        BST t1 = new Branch(bot, 1, bot);
        BST t3 = new Branch(bot, 3, bot);
        BST t2 = new Branch(t1, 2, t3);
        BST t5 = new Branch(bot, 5, bot);
        BST t7 = new Branch(bot, 7, bot);
        BST t6 = new Branch(t5, 6, t7);
        BST t4 = new Branch(t2, 4, t6);
        
        BST a = bot.add(1).add(2).add(3);
        BST b = bot.add(4).add(5).add(6);
        BST c = bot.add(7).add(8).add(9);
        
        System.out.println("t4 should contain 4,2,1,3,6,5,7. Contains " + t4.toString());
        System.out.println("a should be a subset of t4, and should return true. Returns" + a.subset(t4));
        System.out.println("the union of a, b and c should have a cardinality of 9. It is" + a.union(b).union(c).cardinality());
        
    }
}
